package maps

import (
	"archive/zip"
	"encoding/json"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/julienschmidt/httprouter"

	"github.com/noxworld-dev/opennox-lib/ifs"
)

var _ http.Handler = (*Server)(nil)

const (
	contentTypeZIP = "application/zip"
)

var (
	allowedMapExt = []string{
		".map", ".rul", // original ones
		".go",         // Go map scripts
		".lua",        // LUA map scripts
		".txt", ".md", // text files (README, etc)
		// for future extensibility
		".json", ".yml", ".yaml", // metadata
		".png", ".jpg", // image files
		".mp3", ".ogg", // audio files
	}
	excludeMapExt = []string{
		".nxz",                // autogenerated
		".zip", ".tar", ".gz", // don't compress twice
	}
	allowedMapFiles = []string{
		"go.mod", "go.sum", // part of the dev environment for map scripts
	}
	excludeMapFiles = []string{
		"user.rul", // user defined, should not be distributed
		"temp.bmp", // temporary
	}
)

// IsAllowedFile checks if the file with a given name is allowed to be distributed with the map.
func IsAllowedFile(path string) bool {
	path = strings.ToLower(filepath.Base(path))
	for _, name := range excludeMapFiles {
		if path == name {
			return false
		}
	}
	for _, name := range allowedMapFiles {
		if path == name {
			return true
		}
	}
	ext := filepath.Ext(path)
	for _, e := range excludeMapExt {
		if e == ext {
			return false
		}
	}
	for _, e := range allowedMapExt {
		if e == ext {
			return true
		}
	}
	return false // unrecognized
}

func NewServer(path string) *Server {
	s := &Server{path: path, mux: httprouter.New()}
	s.mux.Handle("HEAD", "/api/v0/maps/", s.handleMapList)
	s.mux.Handle("GET", "/api/v0/maps/", s.handleMapList)

	s.mux.Handle("HEAD", "/api/v0/maps/:map", s.handleMap)
	s.mux.Handle("GET", "/api/v0/maps/:map", s.handleMap)
	s.mux.Handle("GET", "/api/v0/maps/:map/download", s.handleMapDownload)
	return s
}

type Server struct {
	mux  *httprouter.Router
	path string
}

func (s *Server) RegisterOnMux(mux *http.ServeMux) {
	mux.Handle("/api/v0/maps/", s)
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	Log.Println(r.Method, r.URL)
	s.mux.ServeHTTP(w, r)
}

func (s *Server) serveJSON(w http.ResponseWriter, obj interface{}) {
	w.Header().Set("Content-Type", "application/json")
	enc := json.NewEncoder(w)
	enc.SetIndent("", "\t")
	enc.Encode(obj)
}

func (s *Server) handleMapList(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
	switch r.Method {
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
	case "HEAD", "OPTIONS":
		w.WriteHeader(http.StatusOK)
	case "GET":
		list, err := Scan(s.path, nil)
		if err != nil {
			Log.Println("error serving map list:", err)
			if len(list) == 0 {
				w.WriteHeader(http.StatusInternalServerError)
				return
			}
			// serve at least some maps
		}
		s.serveJSON(w, list)
	}
}

func (s *Server) handleMap(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
	name := p.ByName("map")
	if name == "" {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	info, err := ReadMapInfo(filepath.Join(s.path, name))
	if os.IsNotExist(err) {
		w.WriteHeader(http.StatusNotFound)
		return
	} else if err != nil {
		Log.Printf("error serving map %q: %v", name, err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	s.serveJSON(w, info)
}

func (s *Server) handleMapDownload(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
	name := p.ByName("map")
	if name == "" {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	base := filepath.Join(s.path, name)
	fname := name + ".map"
	fpath := filepath.Join(base, fname)
	fi, err := ifs.Stat(fpath)
	if os.IsNotExist(err) || fi.IsDir() || fi.Size() == 0 {
		w.WriteHeader(http.StatusNotFound)
		return
	} else if err != nil {
		Log.Printf("error serving map %q: %v", name, err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	accept := r.Header.Get("Accept")
	if accept == "" {
		// serve the map file itself
		f, err := ifs.Open(fpath)
		if err != nil {
			Log.Printf("error serving map %q: %v", name, err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		defer f.Close()
		http.ServeContent(w, r, fname, fi.ModTime(), f)
		return
	}
	// serve compressed map file
	w.Header().Set("Content-Type", contentTypeZIP)
	zw := zip.NewWriter(w)
	defer zw.Close()
	err = ifs.WalkDir(base, func(path string, d ifs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			if d.Type()&fs.ModeSymlink != 0 {
				return filepath.SkipDir // Always skip symlinks.
			}
			return nil // Continue into directories.
		}
		if !d.Type().IsRegular() {
			return nil // Skip symlinks and other non-regular files.
		}
		if !IsAllowedFile(path) {
			return nil // skip
		}
		name, err := filepath.Rel(base, path)
		if err != nil {
			return err
		}
		name = strings.ToLower(name)
		f, err := zw.Create(name)
		if err != nil {
			return err
		}
		r, err := ifs.Open(path)
		if err != nil {
			return err
		}
		defer r.Close()
		_, err = io.Copy(f, r)
		return err
	})
	if err != nil {
		Log.Printf("error serving map %q: %v", name, err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}
